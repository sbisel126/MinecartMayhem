private void startBoatControl(Player player, Boat boat) {
    // Maps to track climbing, drifting, and drift duration
    final Map<Player, Boolean> isClimbing = new ConcurrentHashMap<>();
    final Map<Player, Boolean> isDrifting = new ConcurrentHashMap<>();
    final Map<Player, Long> driftStartTime = new ConcurrentHashMap<>();
    
    // Listen for vehicle control packets (player input)
    protocolManager.addPacketListener(new PacketAdapter(plugin, ListenerPriority.NORMAL, PacketType.Play.Client.STEER_VEHICLE) {
        @Override
        public void onPacketReceiving(PacketEvent event) {
            if (event.getPlayer() != player) return; // Ignore packets from other players

            PacketContainer packet = event.getPacket();
            StructureModifier<Boolean> booleans = packet.getStructures().read(0).getBooleans();

            if (booleans == null) return;

            boolean forward = booleans.read(0);
            boolean backward = booleans.read(1);
            boolean left = booleans.read(2);
            boolean right = booleans.read(3);
            boolean sneaking = event.getPlayer().isSneaking(); // Detect if player is sneaking

            // Drifting requires sneak + turning (left or right)
            boolean drifting = sneaking && (left || right);
            isDrifting.put(player, drifting);
            
            // Start drift timer if drifting begins
            if (drifting && !driftStartTime.containsKey(player)) {
                driftStartTime.put(player, System.currentTimeMillis());
            }

            // Update movement state: 1 = forward, -1 = backward, 0 = idle
            if (forward) {
                movementState.put(player, 1);
            } else if (backward) {
                movementState.put(player, -1);
            } else {
                movementState.put(player, 0);
            }
        }
    });

    // Repeated task to handle movement, physics, and drift mechanics
    new BukkitRunnable() {
        @Override
        public void run() {
            // If the boat is removed or the player exits, clean up
            if (boat.isDead() || !player.isInsideVehicle() || !(player.getVehicle() instanceof Boat)) {
                this.cancel();
                movementState.remove(player);
                isClimbing.remove(player);
                isDrifting.remove(player);
                driftStartTime.remove(player);
                boat.remove();
                player.teleport(new Location(player.getWorld(), -24, -60, 574)); // Send back to hub
                return;
            }

            int state = movementState.getOrDefault(player, 0); // Get movement state
            boolean climbing = isClimbing.getOrDefault(player, false);
            boolean drifting = isDrifting.getOrDefault(player, false);
            
            Vector direction = boat.getLocation().getDirection().normalize();
            Vector velocity = boat.getVelocity();

            // Apply stronger gravity when airborne (for better control)
            if (!boat.isOnGround() && !climbing) {
                velocity.setY(Math.max(velocity.getY() - 0.1, -1.0)); // Adjust gravity as needed
            }

            if (state == 1) { // Moving forward
                if (drifting) {
                    // Apply sideways drifting force (gradual effect for smooth drift)
                    Vector sideways = new Vector(-direction.getZ(), 0, direction.getX()).multiply(0.6); // Reduced from 0.8 to 0.6 for better control
                    velocity.add(sideways);

                    // Slightly reduce forward speed while drifting
                    velocity.multiply(0.97); 

                    // Check if drift boost should activate
                    long driftDuration = System.currentTimeMillis() - driftStartTime.getOrDefault(player, 0L);
                    if (driftDuration > 1200) { // If drifting for >1.2 seconds, apply stronger speed boost
                        velocity.add(direction.multiply(0.4)); // Increased from 0.3 to 0.4 for rewarding drift
                    }
                } else {
                    // Normal acceleration when not drifting
                    velocity.add(direction.multiply(0.12)); // Increased from 0.1 to 0.12 for a slightly better acceleration
                }
            } else if (state == -1) { // Moving backward
                velocity.add(direction.multiply(-0.07)); // Adjusted backward speed (slightly slower)
            } else {
                velocity.multiply(0.94); // Gradual slowdown when idle, making handling smoother
            }

            // Limit the max speed of the boat to prevent unrealistic acceleration
            double maxSpeed = drifting ? 1.5 : 2.2; // Drift mode has lower max speed for better control
            if (velocity.length() > maxSpeed) {
                velocity.normalize().multiply(maxSpeed);
            }

            boat.setVelocity(velocity); // Apply the final calculated velocity
        }
    }.runTaskTimer(plugin, 0L, 1L); // Run every tick (20 times per second)
}
